// lib/core/utils/multi_language_manager.dart

import 'dart:math';
import 'dart:convert';
import 'package:encrypt/encrypt.dart' as encrypt;
import 'package:flutter/foundation.dart';
import 'encryption_gcm_helper.dart';
import '../config/debug_config.dart';

// Helper pour les logs conditionnels
void _debugLog(String message) {
  if (DebugConfig.enableMultiLanguageLogs) {
    debugPrint(message);
  }
}

/// Gestionnaire pour les 10 langues avec AAD chiffr√©
class MultiLanguageManager {
  
  /// S√©lectionne al√©atoirement une langue parmi les 10 disponibles
  static String selectRandomLanguageAAD(Map<String, Map<String, String>> languages) {
    final aadList = languages.keys.toList();
    final random = Random.secure();
    return aadList[random.nextInt(aadList.length)];
  }

  /// Chiffre l'AAD avec la cl√© m√©dia pour masquer quelle langue a √©t√© utilis√©e
  static String encryptAAD(String aad, String mediaKey) {
    try {
      final keyBytes = base64Decode(mediaKey);
      final key = encrypt.Key(keyBytes);
      final iv = encrypt.IV.fromSecureRandom(16);
      final encrypter = encrypt.Encrypter(encrypt.AES(key));

      final encrypted = encrypter.encrypt(aad, iv: iv);

      // Retourner IV:EncryptedAAD en base64
      return '${base64Encode(iv.bytes)}:${encrypted.base64}';
    } catch (e) {
      throw Exception('Erreur chiffrement AAD: $e');
    }
  }

  /// D√©chiffre l'AAD pour identifier quelle langue utiliser
  static String decryptAAD(String encryptedAAD, String mediaKey) {
    try {
      // 1. V√©rifier si c'est un AAD authentifi√© (base64 JSON simple)
      try {
        final decoded = utf8.decode(base64Decode(encryptedAAD));
        final json = jsonDecode(decoded);
        if (json is Map && json.containsKey('v')) {
          debugPrint('üîç DECRYPT_AAD: AAD authentifi√© d√©tect√©, retour direct');
          return decoded;
        }
      } catch (e) {
        // Pas un AAD authentifi√©, continuer avec d√©chiffrement CBC
        debugPrint('üîç DECRYPT_AAD: Pas un AAD authentifi√©, tentative d√©chiffrement CBC');
      }

      // 2. V√©rifier si c'est un format GCM
      if (EncryptionGCMHelper.isGCMFormat(encryptedAAD)) {
        debugPrint('üîç DECRYPT_AAD: Format GCM d√©tect√©, utilisation helper GCM');
        return EncryptionGCMHelper.decryptTextGCM(encryptedAAD, mediaKey);
      }

      // 3. Format CBC classique (IV:ciphertext)
      debugPrint('üîç DECRYPT_AAD: Tentative d√©chiffrement CBC classique');
      final keyBytes = base64Decode(mediaKey);
      final key = encrypt.Key(keyBytes);
      final encrypter = encrypt.Encrypter(encrypt.AES(key));

      final parts = encryptedAAD.split(':');
      if (parts.length != 2) {
        throw Exception('Format AAD CBC invalide (attendu IV:ciphertext)');
      }

      final iv = encrypt.IV(base64Decode(parts[0]));
      final encrypted = encrypt.Encrypted.fromBase64(parts[1]);

      return encrypter.decrypt(encrypted, iv: iv);
    } catch (e) {
      debugPrint('‚ùå DECRYPT_AAD: Erreur d√©chiffrement: $e');
      throw Exception('Erreur d√©chiffrement AAD: $e');
    }
  }

  /// Applique la langue correspondant √† l'AAD
  static String applyLanguageByAAD(
    String text, 
    Map<String, Map<String, String>> languages, 
    String aad
  ) {
    final langMap = languages[aad];
    if (langMap == null) {
      throw Exception('Langue introuvable pour AAD: $aad');
    }
    
    return text.split('').map((c) => langMap[c] ?? c).join('');
  }

  /// Applique la langue inverse correspondant √† l'AAD (pour d√©chiffrement)
  static String applyReverseLanguageByAAD(
    String text, 
    Map<String, Map<String, String>> languages, 
    String aad
  ) {
    final langMap = languages[aad];
    if (langMap == null) {
      throw Exception('Langue introuvable pour AAD: $aad');
    }
    
    final reverseMap = {for (var e in langMap.entries) e.value: e.key};
    return text.split('').map((c) => reverseMap[c] ?? c).join('');
  }

  /// Pr√©pare un message avec langue al√©atoire et AAD chiffr√© (mode legacy v2.0)
  static Map<String, dynamic> prepareMessageWithRandomLanguage(
    String text,
    Map<String, Map<String, String>> languages,
    String mediaKey
  ) {
    // 1. S√©lectionner une langue al√©atoire
    final selectedAAD = selectRandomLanguageAAD(languages);

    // 2. Appliquer la langue au texte
    final codedText = applyLanguageByAAD(text.toLowerCase(), languages, selectedAAD);

    // 3. Chiffrer l'AAD
    final encryptedAAD = encryptAAD(selectedAAD, mediaKey);

    return {
      'codedText': codedText,
      'encryptedAAD': encryptedAAD,
      'selectedAAD': selectedAAD, // Pour debug uniquement
    };
  }

  /// M√©thode unifi√©e pour pr√©parer un message (choisit automatiquement le mode)
  static Map<String, dynamic> prepareMessage(
    String text,
    Map<String, Map<String, String>> languages,
    String mediaKey, {
    bool forcePerCharacterMode = true, // Par d√©faut, utiliser le nouveau mode
    bool autoPrecomputeCache = true, // Pr√©-calculer automatiquement le cache
    bool useGCMEncryption = true, // Utiliser GCM par d√©faut (v2.3)
    bool useAuthenticatedAAD = true, // AAD authentifi√© mais non chiffr√©
  }) {
    debugPrint('üöÄ PREPARE_MESSAGE: D√©but pr√©paration pour: "$text"');
    debugPrint('üöÄ PREPARE_MESSAGE: Langues disponibles: ${languages.length}');
    debugPrint('üöÄ PREPARE_MESSAGE: Mode per-character forc√©: $forcePerCharacterMode');
    debugPrint('üöÄ PREPARE_MESSAGE: Chiffrement GCM: $useGCMEncryption');

    // Pr√©-calculer le cache si demand√© et si on a assez de langues
    if (autoPrecomputeCache && languages.length >= 5) {
      // V√©rifier si le cache est vide ou incomplet
      if (_reverseMapsCache.length < languages.length) {
        debugPrint('üîß PREPARE_MESSAGE: Pr√©-calcul du cache des reverse-maps');
        precomputeReverseMaps(languages);
      }
    }

    // V√©rifier si on peut utiliser le mode per-character
    final canUsePerCharacter = languages.length == 10 && forcePerCharacterMode;

    if (canUsePerCharacter) {
      if (useGCMEncryption) {
        debugPrint('‚úÖ PREPARE_MESSAGE: Utilisation du mode per-character GCM (v2.3)');
        return prepareMessageWithPerCharacterModeGCM(
          text,
          languages,
          mediaKey,
          useAuthenticatedAAD: useAuthenticatedAAD,
        );
      } else {
        debugPrint('‚úÖ PREPARE_MESSAGE: Utilisation du mode per-character CBC (v2.2)');
        return prepareMessageWithPerCharacterMode(text, languages, mediaKey);
      }
    } else {
      debugPrint('‚ö†Ô∏è PREPARE_MESSAGE: Fallback vers mode single-language (v2.0)');
      debugPrint('‚ö†Ô∏è PREPARE_MESSAGE: Raison: langues=${languages.length}, force=$forcePerCharacterMode');
      return prepareMessageWithRandomLanguage(text, languages, mediaKey);
    }
  }

  /// D√©code un message re√ßu avec AAD chiffr√© (mode legacy v2.0)
  static String decodeMessageWithAAD(
    String codedText,
    String encryptedAAD,
    Map<String, Map<String, String>> languages,
    String mediaKey
  ) {
    debugPrint('üîç DECODE_AAD: D√©but d√©codage legacy');
    debugPrint('üîç DECODE_AAD: codedText = $codedText');
    debugPrint('üîç DECODE_AAD: encryptedAAD = $encryptedAAD');
    debugPrint('üîç DECODE_AAD: languages disponibles = ${languages.keys.toList()}');

    try {
      // 1. D√©chiffrer l'AAD pour identifier la langue
      debugPrint('üîç DECODE_AAD: D√©chiffrement AAD...');
      final aad = decryptAAD(encryptedAAD, mediaKey);
      debugPrint('‚úÖ DECODE_AAD: AAD d√©chiffr√© = $aad');

      // 2. Appliquer la langue inverse pour d√©coder
      debugPrint('üîç DECODE_AAD: Application langue inverse...');
      final result = applyReverseLanguageByAAD(codedText, languages, aad);
      debugPrint('‚úÖ DECODE_AAD: R√©sultat final = $result');

      return result;
    } catch (e) {
      debugPrint('‚ùå DECODE_AAD: Erreur = $e');
      rethrow;
    }
  }

  /// M√©thode unifi√©e pour d√©coder un message (d√©tecte automatiquement le mode)
  static String decodeMessage(
    String codedText,
    String encryptedAAD,
    Map<String, Map<String, String>> languages,
    String mediaKey, {
    bool autoPrecomputeCache = true, // Pr√©-calculer automatiquement le cache
    bool autoRepairLanguages = true, // R√©parer automatiquement les langues manquantes
  }) {
    debugPrint('üîç DECODE_UNIFIED: D√©but d√©codage unifi√©');
    debugPrint('üîç DECODE_UNIFIED: codedText = "$codedText"');
    debugPrint('üîç DECODE_UNIFIED: encryptedAAD = ${encryptedAAD.substring(0, 20)}...');

    // Pr√©-calculer le cache si demand√© et si on a assez de langues
    if (autoPrecomputeCache && languages.length >= 5) {
      // V√©rifier si le cache est vide ou incomplet
      if (_reverseMapsCache.length < languages.length) {
        debugPrint('üîß DECODE_UNIFIED: Pr√©-calcul du cache des reverse-maps');
        precomputeReverseMaps(languages);
      }
    }

    try {
      // 1. D√©tecter le mode du message
      debugPrint('üîç DECODE_UNIFIED: D√©tection du mode...');
      final modeInfo = detectMessageMode(encryptedAAD, mediaKey);
      final isPerCharacter = modeInfo['isPerCharacter'] as bool;
      final version = modeInfo['version'] as String;

      debugPrint('‚úÖ DECODE_UNIFIED: Mode d√©tect√© - Version: $version, Per-character: $isPerCharacter');

      // 2. Si mode per-character, v√©rifier la synchronisation des langues
      Map<String, Map<String, String>> workingLanguages = languages;
      if (isPerCharacter && autoRepairLanguages) {
        final sequence = modeInfo['sequence'] as List<String>?;
        if (sequence != null) {
          final diagnosis = diagnoseLanguageSync(sequence, languages);
          if (diagnosis['hasMissingLanguages'] == true) {
            debugPrint('‚ö†Ô∏è DECODE_UNIFIED: Langues manquantes d√©tect√©es, tentative de r√©paration...');
            debugPrint('üîç DECODE_UNIFIED: Diagnostic: $diagnosis');

            workingLanguages = repairMissingLanguages(
              languages,
              diagnosis['missingLanguages'] as List<String>,
            );

            debugPrint('üîß DECODE_UNIFIED: Langues r√©par√©es, nouvelles langues disponibles: ${workingLanguages.keys.length}');
          }
        }
      }

      // 3. D√©coder selon le mode et la version d√©tect√©s
      if (isPerCharacter) {
        if (version == '2.3') {
          debugPrint('üéØ DECODE_UNIFIED: D√©codage per-character GCM (v2.3)');
          // Pour v2.3, v√©rifier si le contenu est au format GCM ou texte cod√©
          if (EncryptionGCMHelper.isGCMFormat(codedText)) {
            // C'est du contenu GCM chiffr√©
            debugPrint('üîê DECODE_UNIFIED: Contenu GCM d√©tect√©');
            // D√©tecter si AAD est authentifi√© ou chiffr√©
            bool isAuthenticatedAAD;
            try {
              final decoded = utf8.decode(base64Decode(encryptedAAD));
              final json = jsonDecode(decoded);
              isAuthenticatedAAD = json is Map && json.containsKey('v');
            } catch (e) {
              isAuthenticatedAAD = false;
            }
            return decodeMessageWithPerCharacterModeGCM(codedText, encryptedAAD, workingLanguages, mediaKey, isAuthenticatedAAD: isAuthenticatedAAD);
          } else {
            // C'est du texte cod√©, probablement un message v2.2 mal d√©tect√©
            debugPrint('‚ö†Ô∏è DECODE_UNIFIED: AAD v2.3 mais contenu non-GCM, fallback vers v2.2');
            return decodeMessageWithPerCharacterMode(codedText, encryptedAAD, workingLanguages, mediaKey);
          }
        } else {
          debugPrint('üéØ DECODE_UNIFIED: D√©codage per-character CBC (v2.2)');
          return decodeMessageWithPerCharacterMode(codedText, encryptedAAD, workingLanguages, mediaKey);
        }
      } else {
        debugPrint('üéØ DECODE_UNIFIED: D√©codage single-language (v2.0)');
        return decodeMessageWithAAD(codedText, encryptedAAD, workingLanguages, mediaKey);
      }
    } catch (e) {
      debugPrint('‚ùå DECODE_UNIFIED: Erreur = $e');

      // Fallback intelligent selon le type d'AAD d√©tect√©
      debugPrint('üîÑ DECODE_UNIFIED: Tentative fallback intelligent...');
      try {
        // V√©rifier si c'est un AAD v2.3 qui a √©chou√©
        String? aadContent;
        try {
          aadContent = decryptAAD(encryptedAAD, mediaKey);
          final aadJson = jsonDecode(aadContent) as Map<String, dynamic>;
          final version = aadJson['v'] as String?;

          if (version == '2.3') {
            debugPrint('üîÑ DECODE_UNIFIED: AAD v2.3 d√©tect√©, pas de fallback legacy possible');
            return '[MESSAGE COMPROMIS] $codedText';
          }
        } catch (aadError) {
          debugPrint('üîÑ DECODE_UNIFIED: Impossible de d√©crypter AAD pour fallback: $aadError');
        }

        // Fallback vers mode legacy seulement pour v2.0/v2.2
        debugPrint('üîÑ DECODE_UNIFIED: Tentative fallback vers mode legacy v2.0...');
        return decodeMessageWithAAD(codedText, encryptedAAD, languages, mediaKey);
      } catch (e2) {
        debugPrint('‚ùå DECODE_UNIFIED: Fallback √©chou√© = $e2');
        // Dernier recours: retourner le texte cod√© avec un message d'erreur
        return '[ERREUR D√âCODAGE] $codedText';
      }
    }
  }

  /// V√©rifie si un package contient le nouveau format (10 langues)
  static bool isMultiLanguagePackage(Map<String, dynamic> package) {
    return package.containsKey('languages') && 
           package['version'] == '2.0' &&
           package['languages'] is Map;
  }

  /// Convertit un ancien package (1 langue) vers le nouveau format (10 langues)
  static Map<String, dynamic> convertLegacyToMultiLanguage(Map<String, dynamic> legacyPackage) {
    if (legacyPackage.containsKey('langMap')) {
      // Cr√©er 10 langues en dupliquant l'ancienne langue avec variations
      final baseLangMap = Map<String, String>.from(legacyPackage['langMap']);
      final languages = <String, Map<String, String>>{};
      
      for (int i = 0; i < 10; i++) {
        final aad = 'lang_${i.toString().padLeft(2, '0')}';
        if (i == 0) {
          // Premi√®re langue = langue originale
          languages[aad] = baseLangMap;
        } else {
          // Autres langues = variations de la langue originale
          languages[aad] = _generateVariation(baseLangMap, i);
        }
      }
      
      return {
        'languages': languages,
        'mediaKey': legacyPackage['mediaKey'],
        'timestamp': legacyPackage['timestamp'],
        'version': '2.0',
        'convertedFrom': '1.0'
      };
    }
    
    throw Exception('Package legacy invalide');
  }

  /// G√©n√®re une variation d'une langue existante
  static Map<String, String> _generateVariation(Map<String, String> baseLangMap, int seed) {
    final random = Random(seed); // Seed fixe pour reproductibilit√©
    final chars = baseLangMap.keys.toList();
    final values = baseLangMap.values.toList();
    
    // M√©langer les valeurs avec le seed
    values.shuffle(random);
    
    final variation = <String, String>{};
    for (int i = 0; i < chars.length; i++) {
      variation[chars[i]] = values[i];
    }
    
    return variation;
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // NOUVEAU: MODE PER-CHARACTER (v2.2)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  /// Cache des reverse-maps pour optimiser les performances
  static final Map<String, Map<String, String>> _reverseMapsCache = {};

  /// Cache des hash de langues pour d√©tecter les changements
  static final Map<String, int> _languageHashCache = {};

  /// Obtient ou calcule la reverse-map pour une langue donn√©e
  static Map<String, String> _getReverseMap(Map<String, String> langMap, String aad) {
    // Calculer un hash simple de la langue pour d√©tecter les changements
    final langHash = langMap.entries.map((e) => '${e.key}:${e.value}').join('|').hashCode;

    // V√©rifier si la langue a chang√©
    if (_languageHashCache[aad] != langHash) {
      debugPrint('üîÑ CACHE: Invalidation cache pour langue $aad (hash chang√©)');
      _reverseMapsCache.remove(aad);
      _languageHashCache[aad] = langHash;
    }

    // Retourner depuis le cache ou calculer
    if (_reverseMapsCache.containsKey(aad)) {
      return _reverseMapsCache[aad]!;
    }

    debugPrint('üîß CACHE: Calcul reverse-map pour langue $aad');
    final reverseMap = {for (var e in langMap.entries) e.value: e.key};
    _reverseMapsCache[aad] = reverseMap;
    return reverseMap;
  }

  /// Trouve une langue de fallback pour une langue manquante
  static String? _findFallbackLanguage(String missingLang, Map<String, Map<String, String>> availableLanguages) {
    // 1. Essayer de trouver une langue avec un nom similaire
    final availableKeys = availableLanguages.keys.toList();

    // Extraire le num√©ro de la langue manquante (ex: lang_04 -> 04)
    final missingMatch = RegExp(r'lang_(\d+)').firstMatch(missingLang);
    if (missingMatch != null) {
      final missingNumber = missingMatch.group(1);

      // Chercher des variantes du m√™me num√©ro
      for (final key in availableKeys) {
        if (key.contains(missingNumber!)) {
          return key;
        }
      }
    }

    // 2. Fallback vers la premi√®re langue disponible
    if (availableKeys.isNotEmpty) {
      debugPrint('üîÑ FALLBACK: Utilisation de ${availableKeys.first} comme fallback universel');
      return availableKeys.first;
    }

    return null;
  }

  /// Pr√©-calcule toutes les reverse-maps pour un ensemble de langues
  static void precomputeReverseMaps(Map<String, Map<String, String>> languages) {
    debugPrint('üöÄ CACHE: Pr√©-calcul des reverse-maps pour ${languages.length} langues');
    final stopwatch = Stopwatch()..start();

    for (final entry in languages.entries) {
      final aad = entry.key;
      final langMap = entry.value;
      _getReverseMap(langMap, aad); // Force le calcul et la mise en cache
    }

    stopwatch.stop();
    debugPrint('‚úÖ CACHE: Pr√©-calcul termin√© en ${stopwatch.elapsedMilliseconds}ms');
    debugPrint('üìä CACHE: ${_reverseMapsCache.length} reverse-maps en cache');
  }

  /// Nettoie le cache des reverse-maps
  static void clearReverseMapsCache() {
    debugPrint('üßπ CACHE: Nettoyage du cache des reverse-maps');
    _reverseMapsCache.clear();
    _languageHashCache.clear();
  }

  /// Obtient des statistiques sur le cache
  static Map<String, dynamic> getCacheStats() {
    return {
      'reverseMapsCount': _reverseMapsCache.length,
      'languageHashCount': _languageHashCache.length,
      'cacheKeys': _reverseMapsCache.keys.toList(),
      'memoryEstimate': _reverseMapsCache.values
          .map((map) => map.length * 50) // Estimation: 50 bytes par entr√©e
          .fold(0, (a, b) => a + b),
    };
  }

  /// G√©n√®re une s√©quence de langues pour chaque caract√®re du texte
  static List<String> _generateLanguageSequence(String text, List<String> availableLanguages) {
    final random = Random.secure();
    final sequence = <String>[];

    // Traiter le texte avec support Unicode complet
    final runes = text.runes.toList();
    for (int i = 0; i < runes.length; i++) {
      // S√©lection al√©atoire d'une langue pour chaque caract√®re
      final selectedLang = availableLanguages[random.nextInt(availableLanguages.length)];
      sequence.add(selectedLang);
    }

    return sequence;
  }

  /// Pr√©pare un message avec le mode per-character (v2.2)
  static Map<String, dynamic> prepareMessageWithPerCharacterMode(
    String text,
    Map<String, Map<String, String>> languages,
    String mediaKey
  ) {
    debugPrint('üîÑ PERCHAR: D√©but pr√©paration per-character pour: "$text"');

    // 1. V√©rifier qu'on a exactement 10 langues
    if (languages.length != 10) {
      throw Exception('Le mode per-character n√©cessite exactement 10 langues (trouv√©: ${languages.length})');
    }

    final availableLanguages = languages.keys.toList();
    debugPrint('üåê PERCHAR: Langues disponibles: $availableLanguages');

    // 2. G√©n√©rer la s√©quence de langues (une par caract√®re)
    final sequence = _generateLanguageSequence(text, availableLanguages);
    debugPrint('üéØ PERCHAR: S√©quence g√©n√©r√©e: $sequence');

    // 3. Appliquer la transformation caract√®re par caract√®re
    final codedChars = <String>[];
    for (int i = 0; i < text.length; i++) {
      final char = text[i];
      final langKey = sequence[i];
      final langMap = languages[langKey]!;
      final codedChar = langMap[char] ?? char; // Laisser inchang√© si pas dans la map
      codedChars.add(codedChar);
    }
    final codedText = codedChars.join('');
    debugPrint('üî§ PERCHAR: Texte cod√©: "$codedText"');

    // 4. Cr√©er le JSON AAD avec la s√©quence
    final aadJson = {
      'v': '2.2',
      'mode': 'perchar-seq',
      'seq': sequence,
    };
    final aadJsonString = jsonEncode(aadJson);
    debugPrint('üìã PERCHAR: AAD JSON: $aadJsonString');

    // 5. Chiffrer l'AAD
    final encryptedAAD = encryptAAD(aadJsonString, mediaKey);
    debugPrint('üîê PERCHAR: AAD chiffr√©: ${encryptedAAD.substring(0, 20)}...');

    return {
      'codedText': codedText,
      'encryptedAAD': encryptedAAD,
      'sequence': sequence, // Pour debug uniquement
      'aadJson': aadJson, // Pour debug uniquement
    };
  }

  /// D√©code un message per-character (v2.2)
  static String decodeMessageWithPerCharacterMode(
    String codedText,
    String encryptedAAD,
    Map<String, Map<String, String>> languages,
    String mediaKey
  ) {
    debugPrint('üîç PERCHAR_DECODE: D√©but d√©codage per-character');
    debugPrint('üîç PERCHAR_DECODE: codedText = "$codedText"');
    debugPrint('üîç PERCHAR_DECODE: encryptedAAD = ${encryptedAAD.substring(0, 20)}...');

    try {
      // 1. D√©chiffrer l'AAD pour obtenir le JSON
      debugPrint('üîì PERCHAR_DECODE: D√©chiffrement AAD...');
      final aadJsonString = decryptAAD(encryptedAAD, mediaKey);
      debugPrint('üìã PERCHAR_DECODE: AAD JSON d√©chiffr√©: $aadJsonString');

      // 2. Parser le JSON AAD
      final aadJson = jsonDecode(aadJsonString) as Map<String, dynamic>;
      final version = aadJson['v'] as String?;
      final mode = aadJson['mode'] as String?;
      final sequence = (aadJson['seq'] as List<dynamic>).cast<String>();

      debugPrint('üìä PERCHAR_DECODE: Version: $version, Mode: $mode');
      debugPrint('üéØ PERCHAR_DECODE: S√©quence: $sequence');

      // 3. V√©rifier le format (accepter v2.2 et v2.3 en mode fallback)
      if ((version != '2.2' && version != '2.3') || mode != 'perchar-seq') {
        throw Exception('Format AAD invalide: v=$version, mode=$mode');
      }

      // Avertissement pour v2.3 en mode fallback
      if (version == '2.3') {
        debugPrint('‚ö†Ô∏è PERCHAR_DECODE: Mode fallback v2.3 -> v2.2 (contenu non-GCM)');
      }

      // 4. V√©rifier la coh√©rence des longueurs (avec support Unicode)
      final codedRunes = codedText.runes.toList();
      if (sequence.length != codedRunes.length) {
        debugPrint('‚ö†Ô∏è PERCHAR_DECODE: Longueur incoh√©rente - seq:${sequence.length}, text:${codedRunes.length}');
        throw Exception('Longueur de s√©quence incoh√©rente avec le texte cod√©');
      }

      // 5. D√©coder caract√®re par caract√®re avec gestion robuste des langues manquantes
      final decodedChars = <String>[];
      final missingLanguages = <String>[];

      for (int i = 0; i < codedRunes.length; i++) {
        final codedChar = String.fromCharCode(codedRunes[i]);
        final langKey = sequence[i];

        if (!languages.containsKey(langKey)) {
          if (!missingLanguages.contains(langKey)) {
            missingLanguages.add(langKey);
            debugPrint('‚ö†Ô∏è PERCHAR_DECODE: Langue $langKey introuvable √† la position $i');
          }

          // Fallback intelligent: essayer de trouver une langue similaire
          final fallbackLang = _findFallbackLanguage(langKey, languages);
          if (fallbackLang != null) {
            debugPrint('üîÑ PERCHAR_DECODE: Utilisation de $fallbackLang comme fallback pour $langKey');
            final langMap = languages[fallbackLang]!;
            final reverseMap = _getReverseMap(langMap, fallbackLang);
            final decodedChar = reverseMap[codedChar] ?? codedChar;
            decodedChars.add(decodedChar);
          } else {
            // Dernier recours: garder le caract√®re tel quel
            decodedChars.add(codedChar);
          }
          continue;
        }

        final langMap = languages[langKey]!;
        final reverseMap = _getReverseMap(langMap, langKey);
        final decodedChar = reverseMap[codedChar] ?? codedChar; // Laisser inchang√© si pas trouv√©
        decodedChars.add(decodedChar);
      }

      // Afficher un r√©sum√© des langues manquantes
      if (missingLanguages.isNotEmpty) {
        debugPrint('‚ö†Ô∏è PERCHAR_DECODE: Langues manquantes: $missingLanguages');
        debugPrint('üîç PERCHAR_DECODE: Langues disponibles: ${languages.keys.toList()}');
        debugPrint('üí° PERCHAR_DECODE: Cela peut indiquer un probl√®me de synchronisation des langues');
      }

      final decodedText = decodedChars.join('');
      debugPrint('‚úÖ PERCHAR_DECODE: Texte d√©cod√©: "$decodedText"');

      return decodedText;
    } catch (e) {
      debugPrint('‚ùå PERCHAR_DECODE: Erreur = $e');
      rethrow;
    }
  }

  /// D√©tecte le mode d'un message √† partir de son AAD chiffr√©
  static Map<String, dynamic> detectMessageMode(String encryptedAAD, String mediaKey) {
    try {
      final aadContent = decryptAAD(encryptedAAD, mediaKey);

      // Essayer de parser comme JSON (v2.2)
      try {
        final aadJson = jsonDecode(aadContent) as Map<String, dynamic>;
        final version = aadJson['v'] as String?;
        final mode = aadJson['mode'] as String?;

        if ((version == '2.2' || version == '2.3') && mode == 'perchar-seq') {
          return {
            'version': version,
            'mode': 'perchar-seq',
            'isPerCharacter': true,
            'sequence': (aadJson['seq'] as List<dynamic>).cast<String>(),
          };
        }
      } catch (e) {
        // Pas un JSON valide, continuer avec le mode legacy
      }

      // Mode legacy (v2.0) - AAD contient directement la cl√© de langue
      return {
        'version': '2.0',
        'mode': 'single-lang',
        'isPerCharacter': false,
        'languageKey': aadContent,
      };
    } catch (e) {
      throw Exception('Impossible de d√©tecter le mode du message: $e');
    }
  }

  /// Statistiques d'utilisation des langues (pour debug)
  static Map<String, int> getLanguageUsageStats(List<String> usedAADs) {
    final stats = <String, int>{};
    for (final aad in usedAADs) {
      stats[aad] = (stats[aad] ?? 0) + 1;
    }
    return stats;
  }

  /// Diagnostique les probl√®mes de synchronisation des langues
  static Map<String, dynamic> diagnoseLanguageSync(
    List<String> requiredLanguages,
    Map<String, Map<String, String>> availableLanguages,
  ) {
    final missing = <String>[];
    final available = availableLanguages.keys.toList();
    final suggestions = <String, String>{};

    for (final required in requiredLanguages) {
      if (!availableLanguages.containsKey(required)) {
        missing.add(required);

        // Chercher des suggestions de fallback
        final fallback = _findFallbackLanguage(required, availableLanguages);
        if (fallback != null) {
          suggestions[required] = fallback;
        }
      }
    }

    return {
      'hasMissingLanguages': missing.isNotEmpty,
      'missingLanguages': missing,
      'availableLanguages': available,
      'fallbackSuggestions': suggestions,
      'totalRequired': requiredLanguages.length,
      'totalAvailable': available.length,
      'syncStatus': missing.isEmpty ? 'OK' : 'DESYNC',
    };
  }

  /// Tente de r√©parer automatiquement les langues manquantes
  static Map<String, Map<String, String>> repairMissingLanguages(
    Map<String, Map<String, String>> languages,
    List<String> missingLanguages,
  ) {
    final repairedLanguages = Map<String, Map<String, String>>.from(languages);

    for (final missingLang in missingLanguages) {
      // Essayer de g√©n√©rer une langue de remplacement
      final fallback = _findFallbackLanguage(missingLang, languages);
      if (fallback != null) {
        // Cr√©er une variation de la langue de fallback
        final baseLangMap = languages[fallback]!;
        final variation = _generateVariation(baseLangMap, missingLang.hashCode);
        repairedLanguages[missingLang] = variation;
        debugPrint('üîß REPAIR: Langue $missingLang g√©n√©r√©e √† partir de $fallback');
      } else {
        // G√©n√©rer une nouvelle langue al√©atoire avec alphabets s√©par√©s (texte‚Üítexte, emoji‚Üíemoji)
        final newLangMap = <String, String>{};

        // üî§ ALPHABET TEXTE (sans emojis) - IDENTIQUE √† lang_map_generator.dart
        const String textAlphabet =
            'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
            '0123456789'
            ' .?!,;:-_()[]{}@#\$%^&*+=<>/\\|`~"\''
            '√†√°√¢√§√¶√ß√®√©√™√´√¨√≠√Æ√Ø√±√≤√≥√¥√∂√π√∫√ª√º√ø'
            '√Ä√Å√Ç√Ñ√Ü√á√à√â√ä√ã√å√ç√é√è√ë√í√ì√î√ñ√ô√ö√õ√ú≈∏'
            '√ü√∂√§√º√ñ√Ñ√ú'
            '√±√ë¬ø¬°'
            '√≤√†√®√¨√π'
            '√£√µ√ß√É√ï√á'
            '√•√¶√∏√Ö√Ü√ò'
            '–∞–±–≤–≥–¥–µ—ë–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è'
            '–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø'
            'Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ'
            'ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©'
            'ÿßÿ®ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑ÿ∏ÿπÿ∫ŸÅŸÇŸÉŸÑŸÖŸÜŸáŸàŸä'
            '‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∫∫Â§ßÂ∞è‰∏≠‰∏ä‰∏ãÂ∑¶Âè≥ÂâçÂæå'
            '„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù„Åü„Å°„Å§„Å¶„Å®„Å™„Å´„Å¨„Å≠„ÅÆ„ÅØ„Å≤„Åµ„Å∏„Åª„Åæ„Åø„ÇÄ„ÇÅ„ÇÇ„ÇÑ„ÇÜ„Çà„Çâ„Çä„Çã„Çå„Çç„Çè„Çí„Çì'
            '„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥'
            '¬±√ó√∑‚àû‚â†‚â§‚â•‚àë‚àè‚àö‚à´‚àÇ‚àá‚àà‚àâ‚à™‚à©‚äÇ‚äÉ‚äÜ‚äá‚àß‚à®¬¨‚àÄ‚àÉ'
            '‚Ç¨¬£¬•¬¢‚Çπ‚ÇΩ‚Ç©‚Ç™‚Ç´‚Ç®‚Ç¶‚Ç°‚Çµ‚Ç¥‚Ç∏‚Çº‚Çæ'
            '‚Üê‚Üë‚Üí‚Üì‚Üî‚Üï‚Üñ‚Üó‚Üò‚Üô‚áê‚áë‚áí‚áì‚áî‚áï'
            '¬©¬Æ‚Ñ¢¬ß¬∂‚Ä†‚Ä°‚Ä¢‚Ä¶‚Ä∞‚Ä≤‚Ä≥‚Äπ‚Ä∫¬´¬ª¬∞¬°¬ø';

        // üòÄ ALPHABET EMOJI (s√©par√©) - IDENTIQUE √† lang_map_generator.dart
        const String emojiAlphabet =
            'üòÄüòÉüòÑüòÅüòÜüòÖüòÇü§£üòäüòáüôÇüôÉüòâüòåüòçü•∞üòòüòóüòôüòöüòãüòõüòùüòúü§™ü§®üßêü§ìüòéü§©ü•≥üòèüòíüòûüòîüòüüòïüôÅüò£üòñüò´üò©ü•∫üò¢üò≠üò§üò†üò°ü§¨ü§Øüò≥ü•µü•∂üò±üò®üò∞üò•üòìü§óü§îü§≠ü§´ü§•üò∂üòêüòëüò¨üôÑüòØüò¶üòßüòÆüò≤ü•±üò¥ü§§üò™üòµü§êü•¥ü§¢ü§Æü§ßüò∑ü§íü§ïü§ëü§†üòàüëøüëπüë∫ü§°üí©üëªüíÄüëΩüëæü§ñüéÉ'
            'üëãüëçüëéüëåü§ûü§üü§òü§ôüëàüëâüëÜüëáüëèüôåüëêü§ùüôèüí™'
            'üíîüíïüíñüíóüíòüíùüíüüíØ'
            'üî•üíß‚≠êüåü‚ú®üéâüéäüéàüéÅüéÄüéÇüç∞üéµüé∂üé§üéßüéÆüéØüé≤üé≠üé®üé™üé´üé¨';

        // Combiner les deux alphabets pour la r√©paration
        const String alphabet = textAlphabet + emojiAlphabet;

        final chars = <String>[];
        final runes = alphabet.runes.toList();
        for (int i = 0; i < runes.length; i++) {
          final char = String.fromCharCode(runes[i]);
          if (!chars.contains(char)) {
            chars.add(char);
          }
        }

        final shuffled = List<String>.from(chars);
        shuffled.shuffle(Random(missingLang.hashCode)); // Seed d√©terministe

        for (int i = 0; i < chars.length; i++) {
          newLangMap[chars[i]] = shuffled[i];
        }

        repairedLanguages[missingLang] = newLangMap;
        debugPrint('üÜï REPAIR: Nouvelle langue $missingLang g√©n√©r√©e (alphabet √©tendu: ${chars.length} caract√®res)');
      }
    }

    return repairedLanguages;
  }

  /// Pr√©pare un message avec mode per-character et chiffrement GCM (v2.3)
  static Map<String, dynamic> prepareMessageWithPerCharacterModeGCM(
    String text,
    Map<String, Map<String, String>> languages,
    String mediaKey, {
    bool useAuthenticatedAAD = true, // AAD authentifi√© mais non chiffr√©
  }) {
    debugPrint('üîÑ PERCHAR_GCM: D√©but pr√©paration per-character GCM pour: "$text"');

    if (languages.length != 10) {
      throw Exception('Mode per-character GCM n√©cessite exactement 10 langues, trouv√©: ${languages.length}');
    }

    // 1. G√©n√©rer la s√©quence al√©atoire
    final availableLanguages = languages.keys.toList();
    final sequence = _generateLanguageSequence(text, availableLanguages);

    debugPrint('üåê PERCHAR_GCM: Langues disponibles: $availableLanguages');
    debugPrint('üéØ PERCHAR_GCM: S√©quence g√©n√©r√©e: $sequence');

    // 2. Transformer caract√®re par caract√®re (avec support Unicode)
    final codedChars = <String>[];
    final runes = text.runes.toList();
    for (int i = 0; i < runes.length; i++) {
      final char = String.fromCharCode(runes[i]);
      final langKey = sequence[i];
      final langMap = languages[langKey]!;
      final codedChar = langMap[char] ?? char; // Fallback si caract√®re non support√©
      codedChars.add(codedChar);
    }

    final codedText = codedChars.join('');
    debugPrint('üî§ PERCHAR_GCM: Texte cod√©: "$codedText"');

    // 3. Cr√©er l'AAD pour GCM (utiliser runes.length pour support Unicode)
    final aadData = EncryptionGCMHelper.createGCMAAD(
      mode: 'perchar-seq',
      sequence: sequence,
      messageLength: runes.length, // üîß FIX: Utiliser runes.length pour les emojis
    );

    debugPrint('üìã PERCHAR_GCM: AAD cr√©√©: $aadData');

    // 4. Chiffrer le contenu avec GCM
    String encryptedContent;
    String? encryptedAAD;

    if (useAuthenticatedAAD) {
      // Option A : AAD authentifi√© mais non chiffr√©
      final aadString = jsonEncode(aadData);
      encryptedContent = EncryptionGCMHelper.encryptTextGCM(
        codedText,
        mediaKey,
        aadData: aadString,
      );
      encryptedAAD = base64Encode(utf8.encode(aadString)); // AAD en clair mais encod√©
      debugPrint('üîê PERCHAR_GCM: Mode AAD authentifi√© (non chiffr√©)');
    } else {
      // Option B : AAD chiffr√© s√©par√©ment
      encryptedContent = EncryptionGCMHelper.encryptTextGCM(codedText, mediaKey);
      encryptedAAD = EncryptionGCMHelper.encryptAADGCM(aadData, mediaKey);
      debugPrint('üîê PERCHAR_GCM: Mode AAD chiffr√© s√©par√©ment');
    }

    debugPrint('üîê PERCHAR_GCM: Contenu chiffr√©: ${encryptedContent.substring(0, 20)}...');
    debugPrint('üîê PERCHAR_GCM: AAD trait√©: ${encryptedAAD.substring(0, 20)}...');

    return {
      'codedText': codedText,
      'encryptedContent': encryptedContent,
      'encryptedAAD': encryptedAAD,
      'sequence': sequence,
      'aadData': aadData,
      'encryptionMode': 'gcm',
      'version': EncryptionGCMHelper.GCM_VERSION,
    };
  }

  /// D√©code un message per-character avec chiffrement GCM (v2.3)
  static String decodeMessageWithPerCharacterModeGCM(
    String encryptedContent,
    String encryptedAAD,
    Map<String, Map<String, String>> languages,
    String mediaKey, {
    bool isAuthenticatedAAD = true,
  }) {
    debugPrint('üîç PERCHAR_GCM_DECODE: D√©but d√©codage per-character GCM');
    debugPrint('üîç PERCHAR_GCM_DECODE: Contenu chiffr√©: ${encryptedContent.substring(0, 20)}...');
    debugPrint('üîç PERCHAR_GCM_DECODE: AAD mode authentifi√©: $isAuthenticatedAAD');

    try {
      // 1. R√©cup√©rer l'AAD
      Map<String, dynamic> aadData;
      String? aadString;

      if (isAuthenticatedAAD) {
        // Option A : AAD authentifi√© mais non chiffr√©
        aadString = utf8.decode(base64Decode(encryptedAAD));
        aadData = jsonDecode(aadString) as Map<String, dynamic>;
        debugPrint('üìã PERCHAR_GCM_DECODE: AAD authentifi√© r√©cup√©r√©: $aadData');
      } else {
        // Option B : AAD chiffr√© s√©par√©ment
        aadData = EncryptionGCMHelper.decryptAADGCM(encryptedAAD, mediaKey);
        aadString = jsonEncode(aadData);
        debugPrint('üìã PERCHAR_GCM_DECODE: AAD d√©chiffr√©: $aadData');
      }

      // 2. Valider l'AAD
      if (!EncryptionGCMHelper.validateAAD(aadData)) {
        throw Exception('AAD GCM invalide: $aadData');
      }

      // 3. Extraire la s√©quence
      final sequence = (aadData['seq'] as List<dynamic>).cast<String>();
      debugPrint('üéØ PERCHAR_GCM_DECODE: S√©quence: $sequence');

      // 4. D√©chiffrer le contenu avec GCM
      final codedText = EncryptionGCMHelper.decryptTextGCM(
        encryptedContent,
        mediaKey,
        aadData: isAuthenticatedAAD ? aadString : null,
      );

      debugPrint('üîì PERCHAR_GCM_DECODE: Contenu d√©chiffr√©: "$codedText"');

      // 5. V√©rifier la coh√©rence des longueurs (avec support Unicode)
      final codedRunes = codedText.runes.toList();
      if (sequence.length != codedRunes.length) {
        throw Exception('Incoh√©rence longueurs: s√©quence=${sequence.length}, texte=${codedRunes.length}');
      }

      // 6. D√©coder caract√®re par caract√®re avec gestion des langues manquantes
      final decodedChars = <String>[];
      final missingLanguages = <String>[];

      for (int i = 0; i < codedRunes.length; i++) {
        final codedChar = String.fromCharCode(codedRunes[i]);
        final langKey = sequence[i];

        if (!languages.containsKey(langKey)) {
          if (!missingLanguages.contains(langKey)) {
            missingLanguages.add(langKey);
            debugPrint('‚ö†Ô∏è PERCHAR_GCM_DECODE: Langue $langKey introuvable √† la position $i');
          }

          // Fallback intelligent
          final fallbackLang = _findFallbackLanguage(langKey, languages);
          if (fallbackLang != null) {
            debugPrint('üîÑ PERCHAR_GCM_DECODE: Utilisation de $fallbackLang comme fallback pour $langKey');
            final langMap = languages[fallbackLang]!;
            final reverseMap = _getReverseMap(langMap, fallbackLang);
            final decodedChar = reverseMap[codedChar] ?? codedChar;
            decodedChars.add(decodedChar);
          } else {
            decodedChars.add(codedChar);
          }
          continue;
        }

        final langMap = languages[langKey]!;
        final reverseMap = _getReverseMap(langMap, langKey);
        final decodedChar = reverseMap[codedChar] ?? codedChar;
        decodedChars.add(decodedChar);
      }

      // Afficher un r√©sum√© des langues manquantes
      if (missingLanguages.isNotEmpty) {
        debugPrint('‚ö†Ô∏è PERCHAR_GCM_DECODE: Langues manquantes: $missingLanguages');
        debugPrint('üîç PERCHAR_GCM_DECODE: Langues disponibles: ${languages.keys.toList()}');
      }

      final result = decodedChars.join('');
      debugPrint('‚úÖ PERCHAR_GCM_DECODE: Texte d√©cod√©: "$result"');

      return result;

    } catch (e) {
      if (e is AuthenticationException) {
        debugPrint('‚ùå PERCHAR_GCM_DECODE: √âchec authentification GCM: $e');
        throw Exception('√âchec authentification GCM: message compromis ou corrompu');
      }

      debugPrint('‚ùå PERCHAR_GCM_DECODE: Erreur: $e');
      rethrow;
    }
  }

  /// G√©n√®re un rapport de debug sur les langues
  static String generateDebugReport(Map<String, Map<String, String>> languages, String mediaKey) {
    final report = StringBuffer();
    report.writeln('üîç Rapport Multi-Langues Debug');
    report.writeln('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    report.writeln('üìä Nombre de langues: ${languages.length}');
    report.writeln('üîë Cl√© m√©dia: ${mediaKey.substring(0, 12)}...');
    report.writeln('üéØ Mode per-character: ${languages.length == 10 ? "‚úÖ Disponible" : "‚ùå Indisponible"}');
    report.writeln('üîê Support GCM: ‚úÖ Disponible');
    report.writeln('');

    languages.forEach((aad, langMap) {
      report.writeln('üåê $aad: ${langMap.length} caract√®res');
      // Exemple de mapping pour les 5 premiers caract√®res
      final examples = langMap.entries.take(5).map((e) => '${e.key}‚Üí${e.value}').join(', ');
      report.writeln('   Exemples: $examples');
    });

    return report.toString();
  }

  /// M√©thode unifi√©e pour d√©coder un message avec support GCM (v2.3)
  ///
  /// [contentOrCoded] : Contenu chiffr√© (GCM) ou texte cod√© (CBC)
  /// [encryptedAAD] : AAD chiffr√© ou authentifi√©
  static String decodeMessageUnified(
    String contentOrCoded,
    String encryptedAAD,
    Map<String, Map<String, String>> languages,
    String mediaKey, {
    bool autoPrecomputeCache = true,
    bool autoRepairLanguages = true,
  }) {
    debugPrint('üîç DECODE_UNIFIED_GCM: D√©but d√©codage unifi√© avec support GCM');
    debugPrint('üîç DECODE_UNIFIED_GCM: contentOrCoded = "${contentOrCoded.length > 20 ? contentOrCoded.substring(0, 20) : contentOrCoded}..."');
    debugPrint('üîç DECODE_UNIFIED_GCM: encryptedAAD = ${encryptedAAD.length > 20 ? encryptedAAD.substring(0, 20) : encryptedAAD}...');

    // Pr√©-calculer le cache si demand√©
    if (autoPrecomputeCache && _reverseMapsCache.length < languages.length) {
      debugPrint('üîß DECODE_UNIFIED_GCM: Pr√©-calcul du cache des reverse-maps');
      precomputeReverseMaps(languages);
    }

    try {
      // 1. D√©tecter si c'est du GCM ou CBC
      final isGCMContent = EncryptionGCMHelper.isGCMFormat(contentOrCoded);
      debugPrint('üîç DECODE_UNIFIED_GCM: Format GCM d√©tect√©: $isGCMContent');

      if (isGCMContent) {
        // Mode GCM (v2.3)
        debugPrint('üîê DECODE_UNIFIED_GCM: D√©codage GCM');

        // D√©tecter si AAD est authentifi√© ou chiffr√©
        // AAD authentifi√© = base64 JSON simple, AAD chiffr√© = format GCM
        bool isAuthenticatedAAD;
        try {
          // Tenter de d√©coder comme JSON base64
          final decoded = utf8.decode(base64Decode(encryptedAAD));
          final json = jsonDecode(decoded);
          isAuthenticatedAAD = json is Map && json.containsKey('v');
        } catch (e) {
          // Si √©chec, c'est probablement chiffr√©
          isAuthenticatedAAD = false;
        }
        debugPrint('üîç DECODE_UNIFIED_GCM: AAD authentifi√© (non chiffr√©): $isAuthenticatedAAD');

        return decodeMessageWithPerCharacterModeGCM(
          contentOrCoded,
          encryptedAAD,
          languages,
          mediaKey,
          isAuthenticatedAAD: isAuthenticatedAAD,
        );
      } else {
        // Mode CBC (v2.0/v2.2) - utiliser la m√©thode existante
        debugPrint('üîê DECODE_UNIFIED_GCM: D√©codage CBC - d√©l√©gation vers m√©thode existante');
        return decodeMessage(
          contentOrCoded,
          encryptedAAD,
          languages,
          mediaKey,
          autoPrecomputeCache: autoPrecomputeCache,
          autoRepairLanguages: autoRepairLanguages,
        );
      }
    } catch (e) {
      debugPrint('‚ùå DECODE_UNIFIED_GCM: Erreur = $e');

      // Gestion sp√©ciale des erreurs d'authentification GCM
      if (e is AuthenticationException) {
        debugPrint('üö® DECODE_UNIFIED_GCM: √âchec authentification GCM - message compromis');
        return '[MESSAGE COMPROMIS] √âchec authentification';
      }

      // Fallback vers la m√©thode existante
      debugPrint('üîÑ DECODE_UNIFIED_GCM: Fallback vers d√©codage CBC...');
      try {
        return decodeMessage(
          contentOrCoded,
          encryptedAAD,
          languages,
          mediaKey,
          autoPrecomputeCache: autoPrecomputeCache,
          autoRepairLanguages: autoRepairLanguages,
        );
      } catch (e2) {
        debugPrint('‚ùå DECODE_UNIFIED_GCM: Fallback √©chou√© = $e2');
        return '[ERREUR D√âCODAGE] $contentOrCoded';
      }
    }
  }
}
